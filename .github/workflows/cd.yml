name: CD - Deploy to AKS (linked from CI or manual)

# Two types of triggers to show variety:
# - Runs automatically when CI on main succeeds (linking workflows)
# - Can also be run manually with inputs
on:
  workflow_run:
    workflows: ["CI - Build & Test (frontend + backend)"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      product_tag:
        description: "Product image tag (default: latest CI SHA)"
        required: false
      order_tag:
        description: "Order image tag (default: latest CI SHA)"
        required: false
      frontend_tag:
        description: "Frontend image tag (default: latest CI SHA)"
        required: false
      environment:
        description: "Target environment"
        required: true
        default: "prod"
        type: choice
        options:
          - dev
          - prod
      product_api_port:
        description: "Product service port"
        required: true
        default: "8000"
      order_api_port:
        description: "Order service port"
        required: true
        default: "8001"

permissions:
  contents: read
  id-token: write

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}

jobs:
  deploy:
    name: Deploy to AKS
    runs-on: ubuntu-latest

    # Map environment based on trigger:
    environment: ${{ github.event_name == 'workflow_run' && 'prod' || inputs.environment }}

    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'workflow_dispatch')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER_NAME }}

      - name: Determine tags
        id: tags
        run: |
          # Default to branch-based tags. When linked from CI on main, use :prod.
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "product_tag=prod" >> $GITHUB_OUTPUT
            echo "order_tag=prod" >> $GITHUB_OUTPUT
            echo "frontend_tag=prod" >> $GITHUB_OUTPUT
          else
            echo "product_tag=${{ inputs.product_tag || 'dev' }}" >> $GITHUB_OUTPUT
            echo "order_tag=${{ inputs.order_tag || 'dev' }}" >> $GITHUB_OUTPUT
            echo "frontend_tag=${{ inputs.frontend_tag || 'dev' }}" >> $GITHUB_OUTPUT
          fi

      # Apply k8s objects (assumes manifests exist in k8s/ folder)
      # If your repo uses different paths, adjust below.
      - name: Apply ConfigMaps/Secrets/DB (once-safe)
        run: |
          kubectl apply -f k8s/infra/ || true

      - name: Deploy backend images
        run: |
          # Assumes deployments & container names:
          #   product: deployment/product-deployment, container "product"
          #   order:   deployment/order-deployment,   container "order"
          kubectl set image deployment/product-deployment product=$ACR_LOGIN_SERVER/product:${{ steps.tags.outputs.product_tag }} --record
          kubectl set image deployment/order-deployment   order=$ACR_LOGIN_SERVER/order:${{ steps.tags.outputs.order_tag }} --record
          kubectl rollout status deployment/product-deployment --timeout=180s
          kubectl rollout status deployment/order-deployment   --timeout=180s

      - name: Capture backend external IPs
        id: getips
        run: |
          # Assumes services:
          #   product-svc (LoadBalancer), order-svc (LoadBalancer)
          PRODUCT_IP=$(kubectl get svc product-svc -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          ORDER_IP=$(kubectl get svc order-svc -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "product_ip=$PRODUCT_IP" >> $GITHUB_OUTPUT
          echo "order_ip=$ORDER_IP" >> $GITHUB_OUTPUT
          echo "Product IP: $PRODUCT_IP"
          echo "Order IP:   $ORDER_IP"

      - name: Inject backend URLs into frontend ConfigMap
        run: |
          # Assumes a ConfigMap named frontend-config with keys PRODUCT_API_URL and ORDER_API_URL
          PRODUCT_URL="http://${{ steps.getips.outputs.product_ip }}:${{ inputs.product_api_port || '8000' }}"
          ORDER_URL="http://${{ steps.getips.outputs.order_ip }}:${{ inputs.order_api_port || '8001' }}"
          kubectl create configmap frontend-config \
            --from-literal=PRODUCT_API_URL="$PRODUCT_URL" \
            --from-literal=ORDER_API_URL="$ORDER_URL" \
            -o yaml --dry-run=client | kubectl apply -f -

      - name: Deploy frontend image
        run: |
          # Assumes deployment/frontend-deployment container "frontend"
          kubectl set image deployment/frontend-deployment frontend=$ACR_LOGIN_SERVER/frontend:${{ steps.tags.outputs.frontend_tag }} --record
          # Restart to pick up fresh ConfigMap if app reads env at startup
          kubectl rollout restart deployment/frontend-deployment
          kubectl rollout status  deployment/frontend-deployment --timeout=180s

      - name: Show frontend service
        run: |
          kubectl get svc frontend-svc -o wide
